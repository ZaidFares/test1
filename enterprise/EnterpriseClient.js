/*
 * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
 *
 * This software is dual-licensed to you under the MIT License (MIT) and
 * the Universal Permissive License (UPL). See the LICENSE file in the root
 * directory for license terms. You may choose either license, or both.
 *
 */

/**
 * @classdesc
 * EnterpriseClient is a enterprise application which is a client of the Oracle IoT Cloud Service.
 * <p>
 * This function is meant to be used for constructing EnterpriseClient objects only when the actual
 * ID of the application associated with the object is known.  An actual validation of the
 * application ID with the cloud is not made at construction and if the application ID is incorrect,
 * a NOT FOUND error from the cloud will be given when the object is actually used (e.g. when
 * calling {@link iotcs.enterprise.EnterpriseClient#getDevices}).
 * <p>
 * If the actual application ID is not known is is better to use the
 * {@link iotcs.enterprise.EnterpriseClient#newClient} method for creating EnterpriseClient objects,
 * an asynchronous method that will first make a request at the cloud server for validation and
 * then pass in the callback the validated object.  This will ensure that no NOT FOUND error is
 * given at first usage of the object.
 *
 * @param {string} appid - The application identifier as it is in the cloud.  This is the actual
 *        application ID generated by the server when creating a new application from the cloud UI.
 *        It is different than the integration ID or application mane.
 * @param {string} [taStoreFile] - The trusted assets store file path to be used for trusted assets
 *        manager creation.  This is optional.  If none is given the default global library
 *        parameter is used: iotcs.oracle.iot.tam.store.  This is used only in the context of endpoint
 *        authentication.
 * @param {string} [taStorePassword] - The trusted assets store file password to be used for trusted
 *        assets manager creation.  This is optional.  If none is given, the default global library
 *        parameter is used: iotcs.oracle.iot.tam.storePassword.  This is used only in the context of
 *        endpoint authentication.
 *
 * @alias iotcs.enterprise.EnterpriseClient
 * @class iotcs.enterprise.EnterpriseClient
 * @extends iotcs.Client
 * @memberof iotcs.enterprise
 * @see {@link iotcs.enterprise.EnterpriseClient.newClient}
 */
iotcs.enterprise.EnterpriseClient = class extends iotcs.Client {
    // Static private/protected functions
    /** @ignore */
    static _deviceMonitorInitialization(virtualDevice) {
        let deviceId = virtualDevice.getEndpointId();
        let urn = virtualDevice.getDeviceModel().urn;
        let postData = {};
        postData[deviceId] = [urn];

        if (!virtualDevice._enterpriseClient._lastUntil) {
            virtualDevice._enterpriseClient._lastUntil =
                Date.now() - iotcs.oracle.iot.client.monitor.pollingInterval;
        }

        iotcs.impl.Https._bearerReq({
            method: 'POST',
            path:   iotcs.impl._reqRoot +
                (virtualDevice._enterpriseClient._appid ?
                    ('/apps/' + virtualDevice._enterpriseClient._appid) : '') +
                '/devices/data' +
                '?formatLimit=' + iotcs.oracle.iot.client.monitor.formatLimit +
                '&formatSince=' + virtualDevice._enterpriseClient._lastUntil
        }, JSON.stringify(postData), (response, error) => {
            if (!response ||
                error ||
                !response.data ||
                !response.until ||
                !(deviceId in response.data) ||
                !(urn in response.data[deviceId]))
            {
                if (error) {
                    iotcs.createError('Error on device initialization data.');
                }
            } else {
                virtualDevice._enterpriseClient._lastUntil = response.until;
                iotcs.enterprise.EnterpriseClient._processMonitorData(response.data, virtualDevice);
            }

            virtualDevice._enterpriseClient._addVirtualDevice(virtualDevice);

        }, () => {
            iotcs.enterprise.EnterpriseClient._deviceMonitorInitialization(virtualDevice);
        }, virtualDevice._enterpriseClient._activeEnterpriseClientImpl);
    }

    /**
     * Returns the name of the storage object from the given URL.
     *
     * @param {URL} storageCloudUrl - The storage cloud URL.
     * @returns {string} The name of the storage object from the given URL.
     * @throws {Error} If there was a problem obtaining the storage object name.
     *
     * @ignore
     */
    static _getObjectNameFromUrl(storageCloudUrl) {
        let objectStoragePattern = new RegExp('https?://(?:objectstorage\\..+\\.oraclecloud\\.com|localhost)(?::\\d+)?/n/[^/]+/b/[^/]+/o/(.+)');
        let match = storageCloudUrl.href.match(objectStoragePattern);

        if (match) {
            if (match.length > 0) {
                return match[1];
            }
        } else {
            let objectStorageClassicPattern = new RegExp('https?://(?:.+\\.storage\\.oraclecloud\\.com|localhost)(?::\\d+)?/v1/[^/]+/[^/]+/(.+)');
            match = storageCloudUrl.href.match(objectStorageClassicPattern);

            if (match) {
                if (match.length > 0) {
                    return match[1];
                }
            }
        }

        throw new Error("storageCloudUrl does not contain object name.");
    }

    /** @ignore */
    static _processMonitorData(data, virtualDevice) {
        let deviceId = virtualDevice.getEndpointId();
        let urn = virtualDevice.getDeviceModel().urn;
        let onChangeArray = [];

        if (data[deviceId] && data[deviceId][urn] && data[deviceId][urn].attributes) {
            let attributesIndex = 0;
            let attributes = data[deviceId][urn].attributes;
            let attribute;
            let oldValue;

            let attributeCallback = attributeValue => {
                let isEqual = false;

                if ((attributeValue instanceof Date) && (oldValue instanceof Date)) {
                    isEqual = attributeValue.getTime() === oldValue.getTime();
                } else {
                    isEqual = attributeValue === oldValue;
                }

                if (!isEqual) {
                    let onChangeTuple = {
                        attribute: attribute,
                        newValue: attributeValue,
                        oldValue: oldValue
                    };

                    if (attribute._onChange) {
                        attribute._onChange(onChangeTuple);
                    }

                    attribute._remoteUpdate(attributeValue);

                    if (virtualDevice._onChange) {
                        let onChangeTupleArray = [];
                        onChangeTupleArray.push(onChangeTuple);
                        virtualDevice._onChange(onChangeTupleArray);
                    }
                }
            };

            for (let attributeName in attributes) {
                attribute = virtualDevice[attributeName];

                if (!attribute) {
                    iotcs.createError('Device model attribute mismatch on monitoring.');
                    return;
                }

                oldValue = attribute._value;

                if (!attribute._isValidValue(attributes[attributeName])) {
                    continue;
                }

                attribute._getNewValue(attributes[attributeName], virtualDevice, attributeCallback);
            }
        }

        if (data[deviceId] && data[deviceId][urn] && data[deviceId][urn].formats) {
            let formats = data[deviceId][urn].formats;
            let alerts = {};
            let dataFormats = {};
            let formatsIndex = 0;
            let obj;

            let formatsUpdateCallback = () => {
                if (obj.onAlerts) {
                    alerts[formatUrn] = formats[formatUrn];
                    obj.onAlerts(formats[formatUrn]);
                } else if (obj.onData) {
                    dataFormats[formatUrn] = formats[formatUrn];
                    obj.onData(formats[formatUrn]);
                }

                if (++formatsIndex === Object.keys(formats).length) {
                    // Run after last format handle.
                    if (virtualDevice.onAlerts && (Object.keys(alerts).length > 0)) {
                        virtualDevice.onAlerts(alerts);
                    }

                    if (virtualDevice.onData && (Object.keys(dataFormats).length > 0)) {
                        virtualDevice.onData(dataFormats);
                    }
                }
            };

            for (let formatUrn in formats) {
                obj = virtualDevice[formatUrn];
                if (!obj) {
                    iotcs.createError('Device model alert/data format mismatch on monitoring.');
                    return;
                }

                obj._formatsLocalUpdate(formats[formatUrn], virtualDevice, formatsUpdateCallback);
            }
        }
    }

    /** @ignore */
    static _remoteBulkMonitor(enterpriseClient) {
        if (enterpriseClient._bulkMonitorInProgress) {
            return;
        }

        enterpriseClient._bulkMonitorInProgress = true;

        if (!enterpriseClient._virtualDevices) {
            enterpriseClient._bulkMonitorInProgress = false;
            return;
        }

        let devices = enterpriseClient._virtualDevices;
        let postData = {};

        for (let devId in devices) {
            let deviceModels = devices[devId];
            postData[devId] = [];

            for (let urn in deviceModels) {
                postData[devId].push(urn);
            }
        }

        if (Object.keys(postData).length > 0) {
            iotcs.impl.Https._bearerReq({
                method: 'POST',
                path: iotcs.impl._reqRoot +
                    (enterpriseClient._appid ? ('/apps/' + enterpriseClient._appid) : '') +
                    '/devices/data' +
                    '?since=' + enterpriseClient._lastUntil +
                    '&formatLimit=' + iotcs.oracle.iot.client.monitor.formatLimit
            }, JSON.stringify(postData), (response, error) => {
                enterpriseClient._bulkMonitorInProgress = false;

                if (!response || error || !response.until || !response.data) {
                    iotcs.createError('Invalid response on monitoring.');
                    return;
                }

                enterpriseClient._lastUntil = response.until;
                let data = response.data;

                for (let devId in data) {
                    for (let urn in data[devId]){
                        if (devices[devId] && devices[devId][urn]) {
                            iotcs.enterprise.EnterpriseClient._processMonitorData(data,
                                devices[devId][urn]);
                        }
                    }
                }
            }, () => {
                iotcs.enterprise.EnterpriseClient._remoteBulkMonitor(enterpriseClient);
            }, enterpriseClient._activeEnterpriseClientImpl);
        } else {
            enterpriseClient._bulkMonitorInProgress = false;
        }
    }

    // Static public functions
    /**
     * Get the all the applications that the user has access to.
     *
     * @returns {iotcs.enterprise.Pageable} A pageable instance with
     * which pages can be requested that contain application info
     * objects as items
     *
     * @memberof iotcs.enterprise.EnterpriseClient
     * @function getApplications
     */
    static getApplications() {
        if (!iotcs.impl.Platform._userAuthNeeded()) {
            iotcs.error('Invalid usage.  User authentication framework needed.');
            return null;
        }

        return new iotcs.enterprise.Pageable({
            method: 'GET',
            path:   iotcs.impl._reqRoot + '/apps'
        }, '', null, null);
    }

    /**
     * Creates an enterprise client based on the application name.
     *
     * @function newClient
     * @memberof iotcs.enterprise.EnterpriseClient
     * @see {@link iotcs.enterprise.EnterpriseClient}
     *
     * @param {string} appName - The application name as it is on the cloud server.
     * @param {function} callback - The callback function.  This function is called with an object as
     *        parameter that is a created and initialized instance of an EnterpriseClient with the
     *        application endpoint id associated with the application name given as parameter.  If the
     *        client creation fails the client object will be <code>null</code> and an error object is
     *        passed as the second parameter in the callback: callback(client, error) where the reason
     *        is in error.message.
     * @param {string} [taStoreFile] - The trusted assets store file path to be used for trusted assets
     *        manager creation.  This is optional.  If none is given the default global library
     *        parameter is used: iotcs.oracle.iot.tam.store.  Also this is used only in the context of
     *        endpoint authentication.
     * @param {string} [taStorePassword] - The trusted assets store file password to be used for trusted
     *        assets manager creation.  This is optional.  If none is given the default global library
     *        parameter is used: iotcs.oracle.iot.tam.storePassword.  Also this is used only in the
     *        context of endpoint authentication.
     */
    static newClient(appName, callback, taStoreFile, taStorePassword) {
        switch (arguments.length) {
        case 0:
            break;
        case 1:
            callback = appName;
            break;
        case 2:
            _mandatoryArg(appName, 'string');
            break;
        case 3:
            callback = arguments[0];
            taStoreFile = arguments[1];
            taStorePassword = arguments[2];
            appName = null;
            break;
        }

        _mandatoryArg(callback, 'function');
        _optionalArg(taStoreFile, 'string');
        _optionalArg(taStorePassword, 'string');

        let enterpriseClient = null;
        let f = null;

        if (!iotcs.impl.Platform._userAuthNeeded()) {
            enterpriseClient = new iotcs.enterprise.EnterpriseClient('none', taStoreFile,
                                                                     taStorePassword);
        }

        if (enterpriseClient && enterpriseClient._activeEnterpriseClientImpl._tam.getClientId()) {
            f = (new iotcs.enterprise.Filter()).eq('integrations.id',
                enterpriseClient._activeEnterpriseClientImpl._tam.getClientId());
        } else {
            f = (new iotcs.enterprise.Filter()).eq('name', appName);
        }

        let request = null;

        request = () => {
            iotcs.impl.Https._bearerReq({
                method: 'GET',
                path: iotcs.impl._reqRoot + '/apps' + (f ? ('?q=' + f.toString()) : '')
            }, '', (response, error) => {
                if (!response ||
                    error ||
                    !response.items ||
                    !Array.isArray(response.items) ||
                    (response.items.length !== 1) ||
                    !response.items[0].id)
                {
                    if (typeof callback === 'function')
                        callback(null, iotcs.createError('Invalid response on client creation request: ',
                                                         error));
                    return;
                }

                try {
                    if (appName && (response.items[0].name !== appName)) {
                        if (typeof callback === 'function')
                            callback(null, iotcs.createError('Application name does not match the name parameter.'));
                        return;
                    }

                    if (enterpriseClient) {
                        enterpriseClient.close();
                    }

                    enterpriseClient = new iotcs.enterprise.EnterpriseClient(response.items[0].id,
                                                                             taStoreFile,
                                                                             taStorePassword);
                    if (typeof callback === 'function') {
                        callback(enterpriseClient);
                    }
                } catch (e) {
                    if (typeof callback === 'function')
                        callback(null, iotcs.createError('Invalid response on client creation request: ',
                                                         e));
                }
            }, request, (enterpriseClient ? enterpriseClient._activeEnterpriseClientImpl : null));
        };

        request();
    }

    constructor(appid, taStoreFile, taStorePassword) {
        _mandatoryArg(appid, 'string');
        _optionalArg(taStoreFile, 'string');
        _optionalArg(taStorePassword, 'string');
        super();


        if (appid.indexOf('/') > -1){
            iotcs.error('Invalid app id parameter given.');
            return;
        }

        this._cache = this._cache || {};
        // this._cache.deviceModels is a JSON object.
        this._appid = appid;
        this._bulkMonitorInProgress = false;
        this._lastUntil = null;
        this._virtualDevices = {};

        if (!iotcs.impl.Platform._userAuthNeeded()) {
            this._enterpriseClientImpl =
                new iotcs.enterprise.impl.EnterpriseClientImpl(taStoreFile, taStorePassword);

            if (this._enterpriseClientImpl &&
                this._enterpriseClientImpl._tam &&
                this._enterpriseClientImpl._tam.getClientId())
            {
                this._activeEnterpriseClientImpl = this._enterpriseClientImpl;
            }

            let self = this;

            let storageHandler = (storDisProgress, error) => {
                let storageObject = storDisProgress.getStorageObject();

                if (error) {
                    if (storageObject._deviceForSync && storageObject._deviceForSync.onError) {
                        let tryValues = {};
                        tryValues[storageObject._nameForSyncEvent] = storageObject.getURI();

                        let onDeviceErrorTuple = {
                            newValues: tryValues,
                            tryValues: tryValues,
                            errorResponse: error
                        };

                        storageObject._deviceForSync.onError(onDeviceErrorTuple);
                    }

                    return;
                }

                if (storageObject) {
                    let state = storDisProgress.getState();
                    let oldSyncStatus = storageObject._getSyncStatus();

                    switch (state) {
                    case iotcs.StorageDispatcher.Progress.State.COMPLETED:
                        storageObject._syncStatus =
                            iotcs.enterprise.StorageObject.SyncStatus.IN_SYNC;
                        break;
                    case iotcs.StorageDispatcher.Progress.State.CANCELLED:
                    case iotcs.StorageDispatcher.Progress.State.FAILED:
                        storage._syncStatus =
                            iotcs.enterprise.StorageObject.SyncStatus.SYNC_FAILED;
                        break;
                    case iotcs.StorageDispatcher.Progress.State.IN_PROGRESS:
                    case iotcs.StorageDispatcher.Progress.State.INITIATED:
                    case iotcs.StorageDispatcher.Progress.State.QUEUED:
                        // Do nothing.
                    }

                    if (oldSyncStatus !== storageObject._getSyncStatus()) {
                        if (storageObject._onSync) {
                            let syncEvent;

                            while ((syncEvent = storageObject._syncEvents._pop()) !== null) {
                                storageObject._onSync(syncEvent);
                            }
                        }
                    }
                }
            };

            new iotcs.enterprise.impl.StorageDispatcher(this).onProgress = storageHandler;
        }

        let self = this;

        this._monitor = new iotcs.impl.Monitor(() => {
            iotcs.enterprise.EnterpriseClient._remoteBulkMonitor(self);
        });

        this._monitor._start();
    }

    // Private/protected functions
    _addVirtualDevice(device) {
        this._removeVirtualDevice(device);

        if (!this._virtualDevices[device.getEndpointId()]) {
            this._virtualDevices[device.getEndpointId()] = {};
        }

        this._virtualDevices[device.getEndpointId()][device.getDeviceModel().urn] = device;
    }

       /**
        * Create a new StorageObject.  arg1 and arg2 are one of these:
        *
        * arg1 = storage object name, arg2 = storage object type
        * or
        * arg1 = storage object URI, arg2 = create storage object callback
        *
        * @param {string} arg1 - The first argument.
        * @param {string | function} arg2 - The second argument.
        *
        * @ignore
        */
    _createStorageObject(arg1, arg2) {
        _mandatoryArg(arg1, "string");

        if (arg2 === undefined) {
            console.log('Error: In _createStorageObject, arg2 cannot be undefined.');
        }

        if ((typeof arg2 === "string") || (arg2 === null)) {
            // createStorageObject(name, type)
            let useVirtualStorageDirectories =
                (iotcs.oracle.iot.client.disableStorageObjectPrefix !== null) &&
                (iotcs.oracle.iot.client.disableStorageObjectPrefix !== false);

            // DJMDJM: I think we don't need to set this._enterpriseCllientImpl._storageObjectName here.
            if (useVirtualStorageDirectories &&
                (this._enterpriseClientImpl._tam.getEndpointId() !== null))
            {
                this._enterpriseClientImpl._storageObjectName =
                    this._enterpriseClientImpl.tam.getEndpointId() + "/" + arg1;
            } else {
                this._enterpriseClientImpl._storageObjectName = arg1;
            }

            return new iotcs.StorageObject(undefined, arg1, arg2, undefined, undefined,
                                           undefined);
        } else {
            // createStorageObject(uri, callback)
            _mandatoryArg(arg2, "function");
            let storageUrlStr = arg1;
            let callback = arg2;
            let urlObj;

            try {
                /** @type {URL} */
                urlObj = iotcs.impl.Platform._createUrl(storageUrlStr);
            } catch(error) {
                throw new Error('Storage Cloud URL is an invalid URL.');
            }

            /** @type {string} */
            const name = this._getObjectNameFromUrl(urlObj);
            /** @type {boolean} */
            let isClassicObjectStorage =
                this._enterpriseClientImpl._isPathClassicObjectStore(urlObj.path);
            /** @type {Uint8Array} */
            let authenticationRequestBody = isClassicObjectStorage ? null :
                iotcs.enterprise.impl.EnterpriseClientImpl._createAuthenticationRequestBody(name,
                                                                                            'HEAD');

            var storageObject = new iotcs.StorageObject(storageUrlStr, name);

            this._enterpriseClientImpl._refreshNewStorageAuthToken(storageObject, () => {
                //                        if (!storageUrlStr.startsWith(storageObject._storageAuthenticationData.storageContainerUrl)) {
                //                            callback(null, new Error('Storage container URL does not match.'));
                //                            return;
                //                        }

                let self = this;

                let options = {
                    agent: false,
                    headers: {},
                    host: urlObj.host,
                    hostname: urlObj.hostname,
                    method: "HEAD",
                    path: urlObj.path,
                    port: urlObj.port || iotcs.oracle.iot.client.storageCloudPort,
                    protocol: urlObj.protocol,
                    rejectUnauthorized: true
                };

                if (isClassicObjectStorage) {
                    options.headers['X-Auth-Token'] =
                        self._.internalClient._.storage_authToken;
                } else {
                    /** @type {object} */
                    let headers = storageObject._storageAuthenticationData.headers;

                    for(let key in headers) {
                        options.headers[key] = headers[key];
                    }
                }

                iotcs.impl.Platform._debug("Request: " + new Date().getTime());
                iotcs.impl.Platform._debug(options.path);
                iotcs.impl.Platform._debug(options);

                let protocol = require('https');

                let req = protocol.request(options, response => {
                    iotcs.impl.Platform._debug();
                    iotcs.impl.Platform._debug("Response: " + response.statusCode + ' ' +
                                               response.statusMessage);
                    iotcs.impl.Platform._debug(response.headers);

                    let body = '';

                    response.on('data', d => {
                        body += d;
                    });

                    response.on('end', () => {
                        if (response.statusCode === iotcs.StatusCode.OK) {
                            let type = response.headers["content-type"];
                            let encoding = response.headers["content-encoding"];
                            let date = new Date(Date.parse(response.headers["last-modified"]));
                            let len = parseInt(response.headers["content-length"]);
                            let storage = new iotcs.StorageObject(storageUrlStr, name, type,
                                                                  encoding, date, len);
                            callback(storage);
                        } else if (response.statusCode === iotcs.StatusCode.UNAUTHORIZED) {
                            this._enterpriseClientImpl._refreshClassicStorageAuthToken(() => {
                                this._createStorageObject(url, callback);
                            });
                        } else {
                            let e = new Error(JSON.stringify({
                                statusCode: response.statusCode,
                                statusMessage: (response.statusMessage ?
                                                response.statusMessage : null),
                                body: body
                            }));

                            callback(null, e);
                        }
                    });
                });

                req.on('abort', error => {
                    callback(nuill, error);
                });

                req.on('error', error => {
                    callback(null, error);
                });

                req.on('timeout', () => {
                    callback(null, new Error('Connection timeout.'));
                });

                req.end();
            });
        }
    }

   get _storageObjectName() {
       return this._enterpriseClientImpl._storageObjectName;
   }

    _isStorageAuthenticated() {
        return this._enterpriseClientImpl._storageAuthenticationData !== null;
    }

    _isStorageTokenExpired() {
        // Period in minutes recalculated in milliseconds.
        return ((this._enterpriseClientImpl._storageAuthenticationData.authTokenStartTime +
                 iotcs.oracle.iot.client.storageTokenPeriod * 60000) < Date.now());
    }

    _removeVirtualDevice(device) {
        if (this._virtualDevices[device.getEndpointId()]) {
            if (this._virtualDevices[device.getEndpointId()][device.getDeviceModel().urn]) {
                delete this._virtualDevices[device.getEndpointId()][device.getDeviceModel().urn];
            }

            if (Object.keys(this._virtualDevices[device.getEndpointId()]).length === 0) {
                delete this._virtualDevices[device.getEndpointId()];
            }
        }
    }

    set _storageObjectName(newName) {
        this._enterpriseClientImpl._storageObjectName = newName;
    }

    /**
     * Synchronizes the storage object by either uploading or downloading the object.
     *
     * @param {iotcs.StorageObject} storageObject - The storage object to sync.
     * @param {function} deliveryCallback - The function to call when
     * @param {function} errorCallback - The function to call when the sync fails.
     * @param {function} processCallback - The function to call when
     */
    _syncStorage(storageObject, deliveryCallback, errorCallback, processCallback, timeout) {
        this._enterpriseClientImpl._refreshNewStorageAuthToken(storageObject, () => {
            /** @type {string} */
            let storageUri;

            if (storageObject._storageAuthenticationData) {
                storageUri = storageObject._storageAuthenticationData.storageUrl;
            } else if (storageObject.getURI()) {
                storageUri = storageObject.getURI();
            } else {
                storageObject._setURI(this._enterpriseClientImpl._storageContainerUrl + "/" +
                                      storageObject.getName());
                /** @type {string} */
                storageUri = storageObject.getURI();
            }

            /** @type {URL} */
            let url = iotcs.impl.Platform._createUrl(storageUri);
            /** @type {string} */
            const name = iotcs.enterprise.EnterpriseClient._getObjectNameFromUrl(url);
            /** @type {boolean} */
            const isClassicObjectStorage =
                  this._activeEnterpriseClientImpl_isPathClassicObjectStore(url.path);

            let options = {
                path: url.path,
                headers: {},
                host: url.host,
                hostname: url.hostname,
                port: url.port || iotcs.oracle.iot.client.storageCloudPort,
                protocol: url.protocol.slice(0, -1)
            };

            if (isClassicObjectStorage) {
                options.headers['X-Auth-Token'] = this._activeEnterpriseClientImpl._storageAuthToken;
            } else {
                // Add OCI headers
                let headers = storageObject._storageAuthenticationData.headers;

                for (const key in headers) {
                    if ("(request-target)" !== key) {
                        options.headers[key] = headers[key];
                    }
                }

                /** type {object} */
                let metadata = storageObject.getCustomMetadata();

                if (metadata) {
                    for (const key in metadata) {
                        options.headers['X-Object-Meta-' + key] = metadata[key];
                    }
                }
            }

            if (storageObject.getInputStream()) {
                // Upload file
                /** @type {Uint8Array} */
                storageObject._storageAuthenticationData = isClassicObjectStorage ?  null : 
                    iotcs.enterprise.impl.EnterpriseClientImpl._createAuthenticationRequestBody(name,
                                                                                                "PUT");

                options.method = "PUT";

                if (storageObject.getLength() == -1) {
                    options.headers['Transfer-Encoding'] = "chunked";
                }

                options.headers['Content-Type'] = storageObject.getType();
                // options.headers['Content-Length'] = contentLength;
                var encoding = storageObject.getEncoding();

                if (encoding) {
                    options.headers['Content-Encoding'] = encoding;
                }

                /** type {object} */
                let metadata = storageObject.getCustomMetadata();

                if (metadata) {
                    for (const key in metadata) {
                        if (isClassicObjectStorage) {
                            options.headers['X-Object-Meta-' + key] = metadata[key];
                        } else {
                            options.headers['opc-meta-' + key] = metadata[key];
                        }
                    }
                }
            } else {
                // Download file
                /** @type {Uint8Array} */
                this._enterpriseClientImpl._storageAuthenticationData = isClassicObjectStorage ?  null :
                    iotcs.enterprise.impl.EnterpriseClientImpl._createAuthenticationRequestBody(name,
                                                                                                "GET");

                options.method = "GET";
            }

            let self = this;

            iotcs.impl.Platform.Https._storageReq(options, storageObject, isClassicObjectStorage,
                                                  deliveryCallback, error =>
            {
                if (error) {
                    let exception = null;

                    try {
                        exception = JSON.parse(error.message);

                        if (exception.statusCode &&
                            (exception.statusCode === iotcs.StatusCode.UNAUTHORIZED))
                        {
                            self._enterpriseClientImpl._refreshNewStorageAuthToken(() => {
                                self._syncStorage(storageObject, deliveryCallback, errorCallback,
                                                  processCallback, timeout);
                            });

                            return;
                        }
                    } catch (error2) {
                        // Do nothing.
                    }

                    errorCallback(storageObject, error, -1);
                }
            }, processCallback);
        });
    }

    // Public functions
    /**
     * Closes the resources used by this Client.
     * This will close all the virtual devices
     * created and associated with this enterprise
     * client.
     *
     * @see {@link iotcs.AbstractVirtualDevice#close}
     * @memberof iotcs.enterprise.EnterpriseClient
     * @function close
     */
    close() {
        this._monitor._stop();
        this._cache.deviceModels = {};

        for (let key in this._virtualDevices) {
            for (let key1 in this._virtualDevices[key]) {
                this._virtualDevices[key][key1].close();
            }
        }
    }

    /**
     * Create a new {@link iotcs.enterprise.StorageObject}.
     *
     * <p>
     * The createStorageObject method works in two modes:
     * </p><p>
     * </p><pre>
     * 1. client.createStorageObject(name, type) - Creates a new
     *    {@link iotcs.enterprise.StorageObject} with the given object name and mime&ndash;type.
     *
     *    Parameters:
     *       {string} name - The unique name to be used to reference the content in storage.
     *       {?string} [type] - The mime-type of the content. If <code>type</code> is <code>null</code>
     *                          or <code>undefined</code>, the mime&ndash;type defaults to
     *                          {@link iotcs.StorageObject.MIME_TYPE}.
     *
     *    Returns:
     *       {iotcs.enterprise.StorageObject} A StorageObject.
     *
     * 2. client.createStorageObject(uri, callback) - Creates a new
     *    {@link iotcs.enterprise.StorageObject} from the URL for a named object in storage and
     *    returns it in a callback. Creates a new {@link iotcs.ExternalObject} if using an external
     *    URI.
     *
     * </p><pre>
     *    Parameters:
     *       {string} url - The URL of the object in the storage cloud.
     *       {function(storage, error)} callback - The callback called once getting storage data
     *                                             completes.
     * </pre>
     *
     * @param {string} arg1 - The first argument.
     * @param {string | function} arg2 - The second argument.
     *
     * @function createStorageObject
     * @memberof iotcs.enterprise.EnterpriseClient
     * @see {@link http://www.iana.org/assignments/media-types/media-types.xhtml|IANA Media Types}
     */
    createStorageObject(arg1, arg2) {
        _mandatoryArg(arg1, "string");

        if ((typeof arg2 === "string") || (arg2 === undefined) || (arg2 === null)) {
            // createStorageObject(name, type)
            let name = arg1;
            let type = arg2;

            let useVirtualStorageDirectories =
                (iotcs.oracle.iot.client.disableStorageObjectPrefix !== null) &&
                (iotcs.oracle.iot.client.disableStorageObjectPrefix !== false);

            // DJMDJM:  Do we need to set this._storageObjectName here?
            if (useVirtualStorageDirectories &&
                (this._enterpriseClientImpl._tam.getEndpointId() !== null))
            {
                this._storageObjectName = this._enterpriseClientImpl._tam.getEndpointId() + "/" + name;
            } else {
                this._enterpriseClientImpl._storageObjectName = name;
            }

            let storage = new iotcs.enterprise.StorageObject(null,
                                                           this._enterpriseClientImpl._storageObjectName,
                                                           type, undefined, undefined, undefined);
            storage._setDevice(self);
            return storage;
        } else {
            // createStorageObject(uri, callback)
            _mandatoryArg(arg2, "function");
            let url = arg1;
            let callback = arg2;

            if (_isStorageCloudURI(url)) {
                this._createStorageObject(url, (storage, error) => {
                    if (error) {
                        callback(null, error);
                        return;
                    }

                    let storageObject = new iotcs.enterprise.StorageObject(storage.getURI(),
                        storage.getName(), storage.getType(), storage.getEncoding(),
                        storage.getDate(), storage.getLength());

                    storageObject._setDevice(self);
                    callback(storageObject);
                });
            } else {
                callback(new iotcs.ExternalObject(url));
            }
        }
    }

    /**
     * Create a VirtualDevice instance with the given device model
     * for the given device identifier. This method creates a new
     * VirtualDevice instance for the given parameters. The client
     * library does not cache previously created VirtualDevice
     * objects.
     * <p>
     * A device model can be obtained by it's afferent URN with the
     * EnterpriseClient if it is registered on the cloud.
     *
     * @param {string} endpointId - The endpoint identifier of the
     * device being modeled.
     * @param {object} deviceModel - The device model object
     * holding the full description of that device model that this
     * device implements.
     * @returns {iotcs.enterprise.VirtualDevice} The newly created virtual device
     *
     * @see {@link iotcs.enterprise.EnterpriseClient#getDeviceModel}
     * @memberof iotcs.enterprise.EnterpriseClient
     * @function createVirtualDevice
     */
    createVirtualDevice(endpointId, deviceModel) {
        _mandatoryArg(endpointId, 'string');
        _mandatoryArg(deviceModel, 'object');
        return new iotcs.enterprise.VirtualDevice(endpointId, deviceModel, this);
    }

    /**
     * Get the list of all active devices implementing the
     * specified device model and application of the client.
     *
     * @param {string} deviceModelUrn - The device model expected.
     * @returns {iotcs.enterprise.Pageable} A pageable instance with
     * which pages can be requested that contain devices as items.
     * A standard device item would have the "id" property that can
     * be used as endpoint id for creating virtual devices.
     *
     * @memberof iotcs.enterprise.EnterpriseClient
     * @function getActiveDevices
     */
    getActiveDevices(deviceModelUrn) {
        _mandatoryArg(deviceModelUrn, 'string');

        let f = new iotcs.enterprise.Filter();

        f = f.and([f.eq('deviceModels.urn', deviceModelUrn),
                   f.eq('connectivityStatus', 'ONLINE'),
                   f.eq('state','ACTIVATED')]);

        return this.getDevices(f, null);
    }


    /**
     * Get the application information that this enterprise client is associated with.
     *
     * @param {function} callback - The callback function. This function is called with the following argument:
     * an appinfo object holding all data and metadata associated to that appid e.g.
     * <code>{ id:"", name:"", description:"", metadata: { key1:"value1", key2:"value2", ... } }</code>.
     * If an error occurs or the response is invalid an error object is passed in callback
     * as the second parameter with the reason in error.message: callback(response, error)
     *
     * @memberof iotcs.enterprise.EnterpriseClient
     * @function getApplication
     */
    getApplication(callback) {
        _mandatoryArg(callback, 'function');

        iotcs.impl.Https._bearerReq({
            method: 'GET',
            path:   iotcs.impl._reqRoot + '/apps/' + this._appid
        }, '', (response, error) => {
            if(!response || error || !response.id){
                callback(null, iotcs.createError('Invalid response on application request: ',
                                                 error));
                return;
            }

            let appinfo = response;
            Object.freeze(appinfo);
            callback(appinfo);
        }, () => {
            self.getApplication(callback);
        }, self._activeEnterpriseClientImpl);
    }

    /**@inheritdoc*/
    getDeviceModel(deviceModelUrn, callback) {
        _mandatoryArg(deviceModelUrn, 'string');
        _mandatoryArg(callback, 'function');

        let deviceModel = this._cache.deviceModels[deviceModelUrn];

        if (deviceModel) {
            callback(deviceModel);
            return;
        }

        let f = (new iotcs.enterprise.Filter()).eq('urn', deviceModelUrn);
        let self = this;

        iotcs.impl.Https._bearerReq({
            method: 'GET',
            path:   iotcs.impl._reqRoot + '/apps/' + this._appid + '/deviceModels' + '?q=' + f.toString()
        }, '', (response, error) => {
            if ((!response) ||
                error ||
                (!response.items) ||
                (!Array.isArray(response.items)) ||
                (response.items.length !== 1))
            {
                callback(null, iotcs.createError('Invalid response on get device model request: ',
                                                 error));
                return;
            }

            let deviceModel = response.items[0];
            Object.freeze(deviceModel);
            self._cache.deviceModels[deviceModelUrn] = deviceModel;
            callback(deviceModel);
        }, () => {
            self.getDeviceModel(deviceModelUrn, callback);
        }, self._activeEnterpriseClientImpl);
    }

    /**
     * Get the device models associated with the application of
     * this enterprise client.
     *
     * @returns {iotcs.enterprise.Pageable} A pageable instance with
     * which pages can be requested that contain device models
     * associated with the application as items. An item can be used
     * to create VirtualDevices.
     *
     * @memberof iotcs.enterprise.EnterpriseClient
     * @function getDeviceModels
     */
    getDeviceModels() {
        return new iotcs.enterprise.Pageable({
            method: 'GET',
            path:   iotcs.impl._reqRoot + '/apps/' + this._appid + '/deviceModels'
        }, '', null, this);
    }

    /**
     * Return a list of Devices associated with the application of the client.  The returned fields are
     * limited to the fields defined in fields. Filters forms a query.  Only endpoints that satisfy all
     * the statements in filters are returned.
     *
     * @param {iotcs.enterprise.Filter} filter - A filter as generated by the Filter class.
     * @param {string[]} [fields] - Array of fields for the selected endpoint. Can be null.
     * @returns {iotcs.enterprise.Pageable} A pageable instance with which pages can be requested that
     *          contain devices as items
     *
     * @memberof iotcs.enterprise.EnterpriseClient
     * @function getDevices
     */
    getDevices(filter, fields) {
        _mandatoryArg(filter, iotcs.enterprise.Filter);
        _optionalArg(fields, 'array');

        // TODO: Simplify query builder.
        let query = '?q=' + filter.toString();

        if (fields) {
            query += '&fields=' + fields.toString();
        }

        query = query + '&includeDecommissioned=false&expand=location,metadata';

        return new iotcs.enterprise.Pageable({
            method: 'GET',
            path:   iotcs.impl._reqRoot + '/apps/' + this._appid + '/devices' + query
        }, '', null, this);
    }
};

